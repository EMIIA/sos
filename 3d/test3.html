
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>3D Точка по линии</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
        }
        #map { 
            position: absolute; 
            top: 0; 
            bottom: 0; 
            width: 100%; 
            background: #f8f9fa; 
        }
    </style>
    <script src="https://sos.emiia.ai/mapbox-gl.js"></script>
    <link href="https://sos.emiia.ai/mapbox-gl.css" rel="stylesheet">
    <link href="https://sos.emiia.ai/css.css" rel="stylesheet">
</head>
<body>
<div id="map"></div>
<script>
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
console.log('Мобильное устройство:', isMobile);

mapboxgl.accessToken = 'YOUR_EMIIA_AI_ACCESS_TOKEN';

const lineCoordinates = [
    [37.630507, 55.833692],
    [37.630877, 55.834026],
    [37.631323, 55.834250],
    [37.631735, 55.834216]
];

const objectSettings = {
    object1: {
        pointColor: '#6fa8dc',
        lineColor: '#3d85c6',
        size: 140,
        animationSpeed: 0.0005,
        elevations: [15, 25, 30, 35],
        modelUri: 'https://sos.emiia.ai/circle_2_glb.glb',
        baseOpacity: 1.0,
        verticalOffset: 0.02
    },
    object2: {
        pointColor: '#f6f6f6',
        lineColor: '#d3d3d3',
        baseSize: 190,
        animationSpeed: 0.0005,
        elevations: [14.98, 24.98, 29.98, 34.98],
        modelUri: 'https://sos.emiia.ai/circle_2_glb.glb',
        baseOpacity: 1.0,
        pulseMin: 0.92,
        pulseMax: 1.08,
        verticalOffset: 0.01
    },
    object3: {
        pointColor: '#3d85c6',
        lineColor: '#3d85c6',
        baseSize: 180,
        animationSpeed: 0.0005,
        elevations: [14.9, 24.9, 29.9, 34.9],
        modelUri: 'https://sos.emiia.ai/circle_2_glb.glb',
        baseOpacity: 0.6,
        verticalOffset: 0.00
    }
};

const map = new mapboxgl.Map({
    container: 'map',
    style: 'https://sos.emiia.ai/3d/tiles.json',
    minZoom: 10,
    center: lineCoordinates[0],
    zoom: 18,
    pitch: 60,
    bearing: 30,
    antialias: true
});

class AnimationEngine {
    constructor() {
        this.state = {
            progress: 0,
            direction: 1,
            isMoving: true,
            currentSegment: 0,
            currentPosition: { lng: lineCoordinates[0][0], lat: lineCoordinates[0][1] },
            currentSegmentIndex: 0,
            currentSegmentProgress: 0,
            baseSize: 1.0,
            pulseTime: performance.now(),
            lastTimestamp: performance.now(),
        };
        
        this.objectStates = {
            obj1: { lastPosKey: null, lastTranslation: null },
            obj2: { lastPosKey: null, lastScale: null, lastOpacity: null, lastTranslation: null },
            obj3: { lastPosKey: null, lastScale: null, lastOpacity: null, lastTranslation: null }
        };

        this.zoomSettings = { minZoom: 15, maxZoom: 22 };
    }

    updateZoom() {
        const zoom = map.getZoom();
        let newBaseSize = 1.0;
        
        if (zoom <= this.zoomSettings.minZoom) {
            newBaseSize = 1.0;
        } else if (zoom >= this.zoomSettings.maxZoom) {
            newBaseSize = 0.3;
        } else {
            const normalizedZoom = (zoom - this.zoomSettings.minZoom) / (this.zoomSettings.maxZoom - this.zoomSettings.minZoom);
            newBaseSize = 1.0 - (normalizedZoom * 0.7);
        }

        if (this.state.baseSize !== newBaseSize) {
            this.state.baseSize = newBaseSize;
            this.updateAllModelScales();
        }
    }

    updateAllModelScales() {
        [objectSettings.object1, objectSettings.object2, objectSettings.object3].forEach((obj, i) => {
            const layerId = `object-layer-${i + 1}`;
            const baseSize = obj.size || obj.baseSize;
            const finalSize = baseSize * this.state.baseSize;
            
            const key = `obj${i + 1}`;
            const scaleKey = `${finalSize.toFixed(3)}`;
            
            if (this.objectStates[key].lastScale !== scaleKey) {
                map.setPaintProperty(layerId, 'model-scale', [finalSize, finalSize, finalSize]);
                this.objectStates[key].lastScale = scaleKey;
            }
        });
    }

    getPulseState(stamp, objectIndex) {
        const cycleProgress = ((stamp - this.state.pulseTime) % 1800) / 1800;
        
        if (cycleProgress < 0.833) {
            const animProgress = cycleProgress / 0.833;
            
            if (objectIndex === 3) {
                return {
                    scale: 1 + (animProgress * 2.0),
                    opacity: Math.max(0.1, 0.6 * (1 - animProgress * 0.9))
                };
            } else if (objectIndex === 2) {
                const pulseRange = objectSettings.object2.pulseMax - objectSettings.object2.pulseMin;
                return {
                    scale: objectSettings.object2.pulseMin + (Math.sin(animProgress * Math.PI * 3) * pulseRange * 0.5),
                    opacity: 1.0
                };
            }
        }
        
        return objectIndex === 3 ? { scale: 1, opacity: 0.1 } : { scale: 1, opacity: 1.0 };
    }

    updateObjectPosition(index, objSettings, lng, lat, segmentIndex, segmentProgress) {
        const key = `obj${index}`;
        const posKey = `${lng.toFixed(9)}-${lat.toFixed(9)}-${segmentIndex}-${segmentProgress.toFixed(3)}`;
        
        if (this.objectStates[key].lastPosKey !== posKey) {
            const sourceId = `object-model-${index}`;
            const layerId = `object-layer-${index}`;
            const source = map.getSource(sourceId);
            
            if (source) {
                const data = source._data || source.data;
                data.geometry.coordinates = [lng, lat];
                source.setData(data);
            }

            const elevation = objSettings.elevations[segmentIndex] + 
                (objSettings.elevations[segmentIndex + 1] - objSettings.elevations[segmentIndex]) * segmentProgress;

            const translation = [0, 0, elevation + objSettings.verticalOffset];
            const translationKey = `${translation[2].toFixed(3)}`;
            
            if (this.objectStates[key].lastTranslation !== translationKey) {
                map.setPaintProperty(layerId, 'model-translation', translation);
                this.objectStates[key].lastTranslation = translationKey;
            }

            this.objectStates[key].lastPosKey = posKey;
        }
    }

    updateObjectPulse(index, stamp, objSettings) {
        if (index === 1) return;

        const key = `obj${index}`;
        const layerId = `object-layer-${index}`;
        
        const state = this.getPulseState(stamp, index);
        const baseSize = objSettings.size || objSettings.baseSize;
        const finalSize = baseSize * this.state.baseSize * state.scale;

        const scaleKey = finalSize.toFixed(3);
        if (this.objectStates[key].lastScale !== scaleKey) {
            map.setPaintProperty(layerId, 'model-scale', [finalSize, finalSize, finalSize]);
            this.objectStates[key].lastScale = scaleKey;
        }

        const opacityKey = state.opacity.toFixed(3);
        if (this.objectStates[key].lastOpacity !== opacityKey) {
            map.setPaintProperty(layerId, 'model-opacity', state.opacity);
            this.objectStates[key].lastOpacity = opacityKey;
        }
    }

    animate(timestamp) {
        if (!this.state.lastTimestamp || timestamp - this.state.lastTimestamp > 100) {
            this.state.lastTimestamp = timestamp;
        }

        const deltaTime = Math.min(timestamp - this.state.lastTimestamp, 40);
        this.state.lastTimestamp = timestamp;

        if (this.state.isMoving) {
            this.state.progress += objectSettings.object1.animationSpeed * this.state.direction * (deltaTime / 16);

            const newSegment = Math.floor(this.state.progress * (lineCoordinates.length - 1));
            
            if (newSegment !== this.state.currentSegment && 
                newSegment > 0 && newSegment < lineCoordinates.length - 1) {
                this.state.currentSegment = newSegment;
                this.state.isMoving = false;
                setTimeout(() => { this.state.isMoving = true; }, 2000);
            }

            if (this.state.progress >= 1 && this.state.direction === 1) {
                this.state.progress = 0.999;
                this.state.isMoving = false;
                setTimeout(() => { this.state.direction = -1; this.state.isMoving = true; }, 2000);
            } else if (this.state.progress <= 0 && this.state.direction === -1) {
                this.state.progress = 0.001;
                this.state.isMoving = false;
                setTimeout(() => { this.state.direction = 1; this.state.isMoving = true; }, 2000);
            }

            this.state.progress = Math.max(0, Math.min(1, this.state.progress));

            this.state.currentSegmentIndex = Math.min(Math.floor(this.state.progress * (lineCoordinates.length - 1)), lineCoordinates.length - 2);
            this.state.currentSegmentProgress = (this.state.progress * (lineCoordinates.length - 1)) - this.state.currentSegmentIndex;

            const startCoord = lineCoordinates[this.state.currentSegmentIndex];
            const endCoord = lineCoordinates[this.state.currentSegmentIndex + 1];
            
            this.state.currentPosition.lng = startCoord[0] + (endCoord[0] - startCoord[0]) * this.state.currentSegmentProgress;
            this.state.currentPosition.lat = startCoord[1] + (endCoord[1] - startCoord[1]) * this.state.currentSegmentProgress;
        }

        const { lng, lat } = this.state.currentPosition;
        const segmentIdx = this.state.currentSegmentIndex;
        const segmentProg = this.state.currentSegmentProgress;

        this.updateObjectPosition(1, objectSettings.object1, lng, lat, segmentIdx, segmentProg);
        this.updateObjectPosition(2, objectSettings.object2, lng, lat, segmentIdx, segmentProg);
        this.updateObjectPosition(3, objectSettings.object3, lng, lat, segmentIdx, segmentProg);

        // Пульсация ТОЛЬКО для объектов 2 и 3
        this.updateObjectPulse(2, timestamp, objectSettings.object2);
        this.updateObjectPulse(3, timestamp, objectSettings.object3);

        requestAnimationFrame((ts) => this.animate(ts));
    }

    start() {
        console.log('Движок запущен (FPS: 25, скорость: 0.0005)');
        this.updateAllModelScales();
        this.state.lastTimestamp = performance.now();
        this.animate(performance.now());
    }
}

const animationEngine = new AnimationEngine();

map.on('style.load', () => {
    map.addSource('mapbox-dem', {
        'type': 'raster-dem',
        'url': 'https://sos.emiia.ai/3d/3d_tiles.json',
        'tileSize': 51,
        'maxzoom': 24
    });
    map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 0.0 });

    // Линии
    ['elevated-line-1', 'elevated-line-2', 'elevated-line-3'].forEach((id, i) => {
        const obj = [objectSettings.object1, objectSettings.object2, objectSettings.object3][i];
        
        map.addSource(id, {
            'type': 'geojson',
            'lineMetrics': true,
            'data': {
                'type': 'Feature',
                'properties': {},
                'geometry': { 'coordinates': lineCoordinates, 'type': 'LineString' }
            }
        });

        map.addLayer({
            'id': id,
            'type': 'line',
            'source': id,
            'layout': {
                'line-z-offset': ['interpolate', ['linear'], ['line-progress'], 0, obj.elevations[0], 1, obj.elevations[obj.elevations.length-1]],
                'line-elevation-reference': 'sea'
            },
            'paint': {
                'line-emissive-strength': 1.0,
                'line-width': 4.0,
                'line-color': obj.lineColor
            }
        });
    });

    // Модели
    [objectSettings.object1, objectSettings.object2, objectSettings.object3].forEach((obj, i) => {
        const layerId = `object-layer-${i + 1}`;
        const sourceId = `object-model-${i + 1}`;
        
        map.addSource(sourceId, {
            'type': 'geojson',
            'data': {
                'type': 'Feature',
                'properties': { 'model-uri': obj.modelUri },
                'geometry': { 'coordinates': lineCoordinates[0], 'type': 'Point' }
            }
        });

        const baseSize = obj.size || obj.baseSize;
        map.addLayer({
            'id': layerId,
            'type': 'model',
            'slot': 'middle',
            'source': sourceId,
            'minzoom': 10,
            'maxzoom': 24,
            'layout': {
                'model-id': ['get', 'model-uri']
            },
            'paint': {
                'model-opacity': obj.baseOpacity,
                'model-rotation': [0, 0, 0],
                'model-scale': [baseSize, baseSize, baseSize],
                'model-color': obj.pointColor,
                'model-color-mix-intensity': 0.8,
                'model-cast-shadows': false,
                'model-translation': [0, 0, obj.elevations[0] + obj.verticalOffset],
                'model-emissive-strength': 1.0,
                'model-scale-mode': 'map'
            }
        });
    });

    let zoomTimeout;
    map.on('zoom', () => {
        clearTimeout(zoomTimeout);
        zoomTimeout = setTimeout(() => animationEngine.updateZoom(), 100);
    });

    map.once('idle', () => {
        setTimeout(() => {
            animationEngine.start();
        }, isMobile ? 3000 : 2000);
    });

    if (!map.getSource('moscow')) {
        map.addSource('moscow', {
            url: 'EMIIA_AI',
            type: 'vector',
        });
    }

    const layers = map.getStyle().layers;
    let labelLayerId;
    for (let i = 0; i < layers.length; i++) {
        if (layers[i].type === 'symbol' && layers[i].layout['text-field']) {
            labelLayerId = layers[i].id;
            break;
        }
    }

    try {
        map.addLayer({
            'id': 'green-base',
            'source': 'moscow',
            'source-layer': 'building',
            'type': 'fill',
            'minzoom': 14,
            'maxzoom': 24,
            'paint': {
                'fill-color': '#a4c2f4',
                'fill-opacity': ['interpolate', ['linear'], ['zoom'], 14, 0.3, 15.5, 0.3, 18, 0.3, 22, 0.3]
            }
        }, labelLayerId);

        map.addLayer({
            'id': 'building-outlines',
            'source': 'moscow',
            'source-layer': 'building',
            'type': 'line',
            'minzoom': 14,
            'maxzoom': 24,
            'paint': {
                'line-color': '#ffffff',
                'line-width': ['interpolate', ['linear'], ['zoom'], 14, 1, 16, 2, 18, 2, 20, 5],
                'line-opacity': 1
            }
        }, labelLayerId);

        map.addLayer({
            'id': '3d-buildings',
            'source': 'moscow',
            'source-layer': 'building',
            'type': 'fill-extrusion',
            'minzoom': 14,
            'maxzoom': 19,
            'paint': {
                'fill-extrusion-color': '#e4e4e4',
                'fill-extrusion-height': ['interpolate', ['linear'], ['zoom'], 14, 0, 15.5, ['get', 'render_height']],
                'fill-extrusion-base': ['case', ['>=', ['get', 'zoom'], 16.5], ['get', 'render_min_height'], 0],
                'fill-extrusion-opacity': ['interpolate', ['linear'], ['zoom'], 14, 0, 15.5, 0.8, 18, 0.0]
            }
        }, labelLayerId);
    } catch (e) {
        console.error('Ошибка зданий:', e);
    }

    map.addSource('polygon-source', {
        type: 'geojson',
        data: {
            type: 'Feature',
            geometry: {
                type: 'Polygon',
                coordinates: [[
                    [37.174014825136595, 55.97747637225763],
                    [37.174223117007614, 55.97745607738463],
                    [37.17408018404612, 55.97699461722809],
                    [37.173873474273904, 55.977014791684724],
                    [37.174014825136595, 55.97747637225763]
                ]]
            },
            properties: { height: 6.9 }
        }
    });

    map.addLayer({
        'id': 'extruded-polygon',
        'type': 'fill-extrusion',
        'source': 'polygon-source',
        'paint': {
            'fill-extrusion-color': '#e4e4e4',
            'fill-extrusion-height': ['get', 'height'],
            'fill-extrusion-base': 3.85,
            'fill-extrusion-opacity': ['interpolate', ['linear'], ['zoom'], 17.9, 0.007, 18.0, 0.009, 18.1, 0.2],
            'fill-extrusion-ambient-occlusion-intensity': 0
        }
    });

    map.setLight({ intensity: 0.1 });
});
</script>
</body>
</html>
