<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>3D Точка по линии</title>
    <style>
        body { margin: 0; padding: 0; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #f8f9fa; }
    </style>
    <script src="https://sos.emiia.ai/mapbox-gl.js "></script>
    <link href="https://sos.emiia.ai/mapbox-gl.css " rel="stylesheet">

<link rel="stylesheet" href="https://sos.emiia.ai/css.css ">


</head>
<body>
    <div id="map"></div>

    <script>
        mapboxgl.accessToken = 'YOUR_EMIIA_AI_ACCESS_TOKEN';
        
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'https://sos.emiia.ai/wifi/tiles_emiia.json ',
            minZoom: 17,
            center: [37.630507, 55.833692],
            zoom: 18,
            pitch: 60,
            bearing: 30,
            antialias: true
        });



map.on('style.load', () => {
    map.addSource('mapbox-dem', {
        'type': 'raster-dem',
        'url': 'https://sos.emiia.ai/3d/3d_tiles.json',
        'tileSize': 512,
        'maxzoom': 24
    });

    map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 0.0 });

    // ОДИНАКОВЫЕ КООРДИНАТЫ ДЛЯ ВСЕХ ТОЧЕК
    const lineCoordinates = [
        [37.630507, 55.833692],
        [37.630877, 55.834026], 
        [37.631323, 55.834250],
        [37.631735, 55.834216]
    ];

    // РАЗНЫЕ ВЫСОТЫ ДЛЯ ТРЕХ ТОЧЕК
    const elevations1 = [15, 25, 30, 35];      // Синяя точка - САМАЯ ВЫСОКАЯ
    const elevations2 = [14.98, 24.98, 29.98, 34.98];  // Светло-серая - ПОСЕРЕДИНЕ
    const elevations3 = [14.9, 24.9, 29.9, 34.9];  // Синяя волна - САМАЯ НИЗКАЯ

    // НАСТРОЙКИ ДЛЯ ТРЕХ ОБЪЕКТОВ С ДОПОЛНИТЕЛЬНЫМИ СМЕЩЕНИЯМИ
    const objectSettings = {
        object1: {
            pointColor: '#6fa8dc',
            lineColor: '#3d85c6',
            size: 140,
            visible: true,
            animationSpeed: 0.0007, // Чуть медленнее
            coordinates: lineCoordinates,
            elevations: elevations1,  // САМАЯ ВЫСОКАЯ
            modelUri: 'https://sos.emiia.ai/circle_2_glb.glb',
            baseOpacity: 1.0,
            fadeOpacity: 1.0,
            verticalOffset: 0.02
        },
        object2: {
            pointColor: '#f6f6f6',
            lineColor: '#d3d3d3', 
            baseSize: 190,
            visible: true,
            animationSpeed: 0.0007,
            coordinates: lineCoordinates,
            elevations: elevations2,  // ПОСЕРЕДИНЕ
            modelUri: 'https://sos.emiia.ai/circle_2_glb.glb',
            baseOpacity: 1,
            fadeOpacity: 1,
            pulseMin: 0.92,  // Относительные значения
            pulseMax: 1.08,
            verticalOffset: 0.01
        },
        object3: {
            pointColor: '#3d85c6',
            lineColor: '#3d85c6',
            baseSize: 180,
            visible: true,
            animationSpeed: 0.0007,
            coordinates: lineCoordinates,
            elevations: elevations3,  // САМАЯ НИЗКАЯ
            modelUri: 'https://sos.emiia.ai/circle_2_glb.glb',
            baseOpacity: 0.6,
            fadeOpacity: 0.0,
            verticalOffset: 0.00
        }
    };

    // НАСТРОЙКИ КОМПЕНСАЦИИ ЗУМА
    const zoomSettings = {
        baseZoom: 20,           // Базовый зум, при котором объекты имеют исходный размер
        minZoom: 15,            // Минимальный зум - дальше объекты не уменьшаются
        maxZoom: 22            // Максимальный зум - дальше объекты не увеличиваются
    };

    // СОЗДАЕМ ЛИНИИ ТРАЕКТОРИЙ ДЛЯ КАЖДОЙ ТОЧКИ
    map.addSource('elevated-line-1', {
        'type': 'geojson',
        'lineMetrics': true,
        'data': createLineData(lineCoordinates, elevations1)
    });

    map.addSource('elevated-line-2', {
        'type': 'geojson', 
        'lineMetrics': true,
        'data': createLineData(lineCoordinates, elevations2)
    });

    map.addSource('elevated-line-3', {
        'type': 'geojson', 
        'lineMetrics': true,
        'data': createLineData(lineCoordinates, elevations3)
    });

    map.addLayer({
        'id': 'elevated-line-1',
        'type': 'line',
        'source': 'elevated-line-1',
        'layout': {
            'line-z-offset': ['interpolate', ['linear'], ['line-progress'], 0, elevations1[0], 1, elevations1[elevations1.length-1]],
            'line-elevation-reference': 'sea'
        },
        'paint': {
            'line-emissive-strength': 1.0,
            'line-width': 4.0,
            'line-color': objectSettings.object1.lineColor
        }
    });

    map.addLayer({
        'id': 'elevated-line-2',
        'type': 'line',
        'source': 'elevated-line-2', 
        'layout': {
            'line-z-offset': ['interpolate', ['linear'], ['line-progress'], 0, elevations2[0], 1, elevations2[elevations2.length-1]],
            'line-elevation-reference': 'sea'
        },
        'paint': {
            'line-emissive-strength': 1.0,
            'line-width': 4.0,
            'line-color': objectSettings.object2.lineColor
        }
    });

    map.addLayer({
        'id': 'elevated-line-3',
        'type': 'line',
        'source': 'elevated-line-3', 
        'layout': {
            'line-z-offset': ['interpolate', ['linear'], ['line-progress'], 0, elevations3[0], 1, elevations3[elevations3.length-1]],
            'line-elevation-reference': 'sea'
        },
        'paint': {
            'line-emissive-strength': 1.0,
            'line-width': 4.0,
            'line-color': objectSettings.object3.lineColor
        }
    });

    // СОЗДАЕМ ИСТОЧНИКИ ДЛЯ ТРЕХ ОБЪЕКТОВ
    const objectSource1 = createObjectSource(lineCoordinates[0], objectSettings.object1.modelUri);
    const objectSource2 = createObjectSource(lineCoordinates[0], objectSettings.object2.modelUri);
    const objectSource3 = createObjectSource(lineCoordinates[0], objectSettings.object3.modelUri);

    map.addSource('object-model-1', objectSource1);
    map.addSource('object-model-2', objectSource2);
    map.addSource('object-model-3', objectSource3);

    // ДОБАВЛЯЕМ СЛОИ ДЛЯ ОБЪЕКТОВ С ФИКСИРОВАННЫМ РАЗМЕРОМ
    addObjectLayer('object-1', 'object-model-1', objectSettings.object1);
    addObjectLayer('object-2', 'object-model-2', objectSettings.object2);
    addObjectLayer('object-3', 'object-model-3', objectSettings.object3);

    // СИСТЕМА УПРАВЛЕНИЯ РАЗМЕРОМ ПРИ ЗУМЕ
    let currentBaseSize = 1.0;
    let currentWaveScale = 1.0;
    let currentWaveOpacity = 0.6;
    let currentMiddleScale = 1.0;
    let currentMiddleOpacity = 1.0;
    
    function updateModelScaleForZoom() {
        const zoom = map.getZoom();
        
        if (zoom <= zoomSettings.minZoom) {
            currentBaseSize = 1.0;
        } else if (zoom >= zoomSettings.maxZoom) {
            currentBaseSize = 0.3;
        } else {
            const normalizedZoom = (zoom - zoomSettings.minZoom) / (zoomSettings.maxZoom - zoomSettings.minZoom);
            currentBaseSize = 1.0 - (normalizedZoom * 0.7);
        }

        // Обновляем размеры всех точек
        updateAllBaseSizes();
    }

    // Функция для обновления базовых размеров всех точек
    function updateAllBaseSizes() {
        if (objectSettings.object1.visible) {
            const finalSize = objectSettings.object1.size * currentBaseSize;
            map.setPaintProperty('object-layer-1', 'model-scale', [
                finalSize, finalSize, finalSize
            ]);
        }

        if (objectSettings.object2.visible) {
            // Для средней точки используем комбинацию базового размера и анимационного масштаба
            const baseSize = objectSettings.object2.baseSize * currentBaseSize;
            const animatedSize = baseSize * currentMiddleScale;
            map.setPaintProperty('object-layer-2', 'model-scale', [
                animatedSize, animatedSize, animatedSize
            ]);
            map.setPaintProperty('object-layer-2', 'model-opacity', currentMiddleOpacity);
        }

        if (objectSettings.object3.visible) {
            // Для волны используем комбинацию базового размера и анимационного масштаба
            const baseSize = objectSettings.object3.baseSize * currentBaseSize;
            const animatedSize = baseSize * currentWaveScale;
            map.setPaintProperty('object-layer-3', 'model-scale', [
                animatedSize, animatedSize, animatedSize
            ]);
            map.setPaintProperty('object-layer-3', 'model-opacity', currentWaveOpacity);
        }
    }

    // ПУЛЬСАЦИЯ ДЛЯ ВТОРОЙ И ТРЕТЬЕЙ ТОЧЕК (ИСПРАВЛЕННАЯ)
    class ExpandAndFadePulse {
        constructor() {
            this.startTime = performance.now();
            this.cycleDuration = 1500;
            this.totalCycle = 1800;
        }
        
        getCurrentState(settings) {
            const currentTime = performance.now();
            const elapsed = currentTime - this.startTime;
            const cycleProgress = (elapsed % this.totalCycle) / this.totalCycle;
            
            let opacity, scale;
            
            if (cycleProgress < (this.cycleDuration / this.totalCycle)) {
                const animProgress = cycleProgress / (this.cycleDuration / this.totalCycle);
                
                // Для третьей точки - расширяется и исчезает
                if (settings === objectSettings.object3) {
                    scale = 1 + (animProgress * 2.5); // Увеличенное расхождение
                    opacity = settings.baseOpacity * (1 - animProgress);
                } 
                // Для второй точки - легкая пульсация размера
                else if (settings === objectSettings.object2) {
                    const pulseRange = settings.pulseMax - settings.pulseMin;
                    scale = settings.pulseMin + (Math.sin(animProgress * Math.PI * 4) * pulseRange * 0.5);
                    opacity = settings.baseOpacity;
                }
            } else {
                scale = 1;
                opacity = settings === objectSettings.object3 ? 0 : settings.baseOpacity;
            }
            
            return { opacity, scale };
        }
    }

    const pulseAnimator = new ExpandAndFadePulse();

    function animatePulse() {
        // Первая точка (САМАЯ ВЫСОКАЯ) - всегда статична
        if (objectSettings.object1.visible) {
            map.setPaintProperty('object-layer-1', 'model-opacity', objectSettings.object1.baseOpacity);
        }

        // Вторая точка (ПОСЕРЕДИНЕ) - легкая пульсация
        if (objectSettings.object2.visible) {
            const state = pulseAnimator.getCurrentState(objectSettings.object2);
            
            // Сохраняем текущие значения анимации для использования в updateAllBaseSizes
            currentMiddleScale = state.scale;
            currentMiddleOpacity = state.opacity;
            
            // Обновляем среднюю точку с учетом и зума и анимации
            const baseSize = objectSettings.object2.baseSize * currentBaseSize;
            const animatedSize = baseSize * currentMiddleScale;
            
            map.setPaintProperty('object-layer-2', 'model-opacity', currentMiddleOpacity);
            map.setPaintProperty('object-layer-2', 'model-scale', [
                animatedSize, 
                animatedSize, 
                animatedSize
            ]);
        }

        // Третья точка (САМАЯ НИЗКАЯ) - расширяется и исчезает
        if (objectSettings.object3.visible) {
            const state = pulseAnimator.getCurrentState(objectSettings.object3);
            
            // Сохраняем текущие значения анимации для использования в updateAllBaseSizes
            currentWaveScale = state.scale;
            currentWaveOpacity = state.opacity;
            
            // Обновляем волну с учетом и зума и анимации
            const baseSize = objectSettings.object3.baseSize * currentBaseSize;
            const animatedSize = baseSize * currentWaveScale;
            
            map.setPaintProperty('object-layer-3', 'model-opacity', currentWaveOpacity);
            map.setPaintProperty('object-layer-3', 'model-scale', [
                animatedSize, 
                animatedSize, 
                animatedSize
            ]);
        }
        
        requestAnimationFrame(animatePulse);
    }

    // АНИМАЦИЯ ДВИЖЕНИЯ С ВОЗВРАТОМ И ОСТАНОВКАМИ
    let progress = 0;
    let direction = 1; // 1 = вперед, -1 = назад
    let isMoving = true;
    let currentSegment = 0;
    
    function animateObjects() {
        if (!isMoving) {
            requestAnimationFrame(animateObjects);
            return;
        }
        
        progress += objectSettings.object1.animationSpeed * direction;
        
        // Определяем текущий сегмент
        const newSegment = Math.floor(progress * (lineCoordinates.length - 1));
        
        // Если перешли на новый сегмент - проверяем остановку
        if (newSegment !== currentSegment) {
            currentSegment = newSegment;
            
            // Останавливаемся на промежуточных точках (кроме начальной и конечной)
            if (currentSegment > 0 && currentSegment < lineCoordinates.length - 1) {
                isMoving = false;
                console.log(`Остановка на промежуточной точке ${currentSegment} на 2 секунды`);
                setTimeout(() => {
                    isMoving = true;
                    console.log('Продолжаем движение');
                }, 2000); // Остановка 2 секунды
            }
        }
        
        // Если достигли конца пути вперед - меняем направление
        if (progress >= 1 && direction === 1) {
            progress = 0.99;
            isMoving = false;
            console.log('Достигнута конечная точка, остановка на 2 секунды');
            setTimeout(() => {
                direction = -1;
                isMoving = true;
                console.log('Начинаем обратный путь');
            }, 2000); // Остановка 2 секунды
        }
        
        // Если достигли начала пути назад - меняем направление
        if (progress <= 0 && direction === -1) {
            progress = 0.01;
            isMoving = false;
            console.log('Достигнута начальная точка, остановка на 2 секунды');
            setTimeout(() => {
                direction = 1;
                isMoving = true;
                console.log('Начинаем прямой путь');
            }, 2000); // Остановка 2 секунды
        }

        // Ограничиваем прогресс
        progress = Math.max(0, Math.min(1, progress));

        // Все точки движутся вместе по одним координатам
        const segmentIndex = Math.floor(progress * (lineCoordinates.length - 1));
        const segmentProgress = (progress * (lineCoordinates.length - 1)) - segmentIndex;
        
        const startCoord = lineCoordinates[segmentIndex];
        const endCoord = lineCoordinates[segmentIndex + 1];
        
        const currentLng = startCoord[0] + (endCoord[0] - startCoord[0]) * segmentProgress;
        const currentLat = startCoord[1] + (endCoord[1] - startCoord[1]) * segmentProgress;

        // Обновляем позиции всех точек с учетом вертикальных смещений
        if (objectSettings.object1.visible) {
            const startElevation = elevations1[segmentIndex];
            const endElevation = elevations1[segmentIndex + 1];
            const currentElevation = startElevation + (endElevation - startElevation) * segmentProgress;
            
            objectSource1.data.geometry.coordinates = [currentLng, currentLat];
            map.getSource('object-model-1').setData(objectSource1.data);
            map.setPaintProperty('object-layer-1', 'model-translation', [
                0, 
                0, 
                currentElevation + (objectSettings.object1.verticalOffset || 0)
            ]);
        }

        if (objectSettings.object2.visible) {
            const startElevation = elevations2[segmentIndex];
            const endElevation = elevations2[segmentIndex + 1];
            const currentElevation = startElevation + (endElevation - startElevation) * segmentProgress;
            
            objectSource2.data.geometry.coordinates = [currentLng, currentLat];
            map.getSource('object-model-2').setData(objectSource2.data);
            map.setPaintProperty('object-layer-2', 'model-translation', [
                0, 
                0, 
                currentElevation + (objectSettings.object2.verticalOffset || 0)
            ]);
        }

        if (objectSettings.object3.visible) {
            const startElevation = elevations3[segmentIndex];
            const endElevation = elevations3[segmentIndex + 1];
            const currentElevation = startElevation + (endElevation - startElevation) * segmentProgress;
            
            objectSource3.data.geometry.coordinates = [currentLng, currentLat];
            map.getSource('object-model-3').setData(objectSource3.data);
            map.setPaintProperty('object-layer-3', 'model-translation', [
                0, 
                0, 
                currentElevation + (objectSettings.object3.verticalOffset || 0)
            ]);
        }

        requestAnimationFrame(animateObjects);
    }

    // ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
    function createLineData(coordinates, elevations) {
        return {
            'type': 'Feature',
            'properties': {
                'elevation': elevations
            },
            'geometry': {
                'coordinates': coordinates,
                'type': 'LineString'
            }
        };
    }

    function createObjectSource(coord, modelUri) {
        return {
            'type': 'geojson',
            'data': {
                'type': 'Feature',
                'properties': {
                    'model-uri': modelUri
                },
                'geometry': {
                    'coordinates': coord,
                    'type': 'Point'
                }
            }
        };
    }

    function addObjectLayer(layerId, sourceId, settings) {
        const baseSize = settings.baseSize || settings.size;
        
        map.addLayer({
            'id': `object-layer-${layerId.slice(-1)}`,
            'type': 'model',
            'slot': 'middle',
            'source': sourceId,
            'minzoom': 10,
            'maxzoom': 24,
            'layout': {
                'model-id': ['get', 'model-uri'],
                'visibility': settings.visible ? 'visible' : 'none'
            },
            'paint': {
                'model-opacity': settings.baseOpacity || 1.0,
                'model-rotation': [0, 0, 0],
                'model-scale': [baseSize, baseSize, baseSize],
                'model-color': settings.pointColor,
                'model-color-mix-intensity': 0.8,
                'model-cast-shadows': false,
                'model-translation': [0, 0, settings.elevations[0] + (settings.verticalOffset || 0)],
                'model-emissive-strength': 1.0,
                // ФИКСИРОВАННЫЙ РАЗМЕР - КАК У КОТА
                'model-scale-mode': 'map'
            }
        });
    }

    // СЛУШАЕМ ИЗМЕНЕНИЯ ЗУМА
    map.on('zoom', updateModelScaleForZoom);

    // ФУНКЦИИ ДЛЯ УПРАВЛЕНИЯ
    window.toggleMovement = function() {
        isMoving = !isMoving;
        console.log('Движение:', isMoving ? 'ВКЛ' : 'ВЫКЛ');
    };

    window.resetAnimation = function() {
        progress = 0;
        direction = 1;
        isMoving = true;
        currentSegment = 0;
        console.log('Анимация сброшена в начальное положение');
    };

    // Функция для настройки параметров зума
    window.updateZoomSettings = function(minZoom, maxZoom, baseZoom = 20) {
        zoomSettings.minZoom = minZoom;
        zoomSettings.maxZoom = maxZoom;
        zoomSettings.baseZoom = baseZoom;
        console.log('Настройки зума обновлены:', zoomSettings);
        updateModelScaleForZoom();
    };

    // Остальные функции управления остаются без изменений
    window.updateObject1 = function(property, value) {
        objectSettings.object1[property] = value;
        updateObjectProperties('object-1', objectSettings.object1);
        updateModelScaleForZoom();
    };

    window.updateObject2 = function(property, value) {
        objectSettings.object2[property] = value;
        updateObjectProperties('object-2', objectSettings.object2);
        updateModelScaleForZoom();
    };

    window.updateObject3 = function(property, value) {
        objectSettings.object3[property] = value;
        updateObjectProperties('object-3', objectSettings.object3);
        updateModelScaleForZoom();
    };

    function updateObjectProperties(objectId, settings) {
        const layerId = `object-layer-${objectId.slice(-1)}`;
        const lineLayerId = `elevated-line-${objectId.slice(-1)}`;

        map.setLayoutProperty(layerId, 'visibility', settings.visible ? 'visible' : 'none');
        map.setLayoutProperty(lineLayerId, 'visibility', settings.visible ? 'visible' : 'none');
        map.setPaintProperty(layerId, 'model-color', settings.pointColor);
    }

    // ЗАПУСК АНИМАЦИЙ
    map.once('idle', () => {
        setTimeout(() => {
            animateObjects();
            animatePulse();
            // Инициализируем правильный размер при загрузке
            updateModelScaleForZoom();
        }, 1000);
    });

    console.log('Три точки идут вместе с возвратом и остановками!');
    console.log('Остановки по 2 секунды на всех промежуточных точках');
    console.log('СИНЯЯ (сверху), СЕРАЯ (посередине), ВОЛНА (снизу)');
    console.log('Управление: toggleMovement(), resetAnimation()');
    console.log('ФИКСИРОВАННЫЙ РАЗМЕР: точки не увеличиваются при приближении камеры');
});

</script>
</body>
</html>
